---
title: "Class 3"
author: "Pernille Brams"
date: "22/2/2024"
output:
  html_document:
    toc: true  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Setting my root directory to where I have my /data folder etc. (easier for me, but personalise to your own way of working)
knitr::opts_knit$set(root.dir = "../")

```

```{r libs}
library(pacman)

pacman::p_load(tidyverse,
               ggpubr,
               ggplot2)

```

# Continuing learning about simulations (and practicing a bit)
In coding, repetition is key when learning it... (at least it is for me) - it's kind of like when you learn a new language :333 n'est pas??

Choose your exercises as per your needs - all of this is highly relevant for the remaining portfolios and exercises. In a few weeks, you'll get the opportunity (only if you want to) to submit answers to some exercises I'll give you (including some like the ones below) to me, and I'll review them and give you feedback.

Also, never feel 'guilty' for using hints / ask for help. Hints are there and we are there to help out. Try first on your own, and use the hint/ask when you feel your working memory slacking a bit :)) Just make sure you have some idea about what's going on in the code, also after you've used the hint.

## A. Need some more practice in for loops?
### A1 Using a for-loop, calculate the sum of the first 100 positive integers, starting from 1
Result to check: You should get 5050.

Hint A1* under Hints
```{r}
sum_of_numbers <- 0

for (i in 1:100){
  sum_of_numbers <- sum_of_numbers+i
}
sum_of_numbers
```

### A2 Using a for-loop, create a vector of the squares of the first 20 positive integers, starting from 1. Calculate the sum of the vector.
Result to check: You should get 2870.

Hint A2* under Hints
```{r}
vector_of_squares <- c()

for (i in 1:20){
  vector_of_squares[i] <- i^2
}
sum(vector_of_squares)
```

## B. Need some more practice in while loops? 
### B1 Use a while loop to find the smallest integer n, such that the sum of the first n positive integers is greater than 1000.
Result to check: You should get 45 here

Hint B1* under Hints

```{r}
sum_of_stuff <- 0
runs <- 0
while (sum_of_stuff < 1000) {
  runs <- runs +1
  sum_of_stuff <- sum_of_stuff + runs

}
runs
```

### B2 Create a countdown from 10 to 1 and then print "Lift off!".

Hint B2* under Hints

```{r}
for (i in 10:0){
  if (i %in% 1:10){
    print(i)
  }else{print('Lift off!')}
}
```

## C. Need some more practice in if-else statement? 
### C1 Write code to determine if a given integer x is positive, negative, or zero, for the following values for x: 
-4
7
23
-120309
0

```{r}
numbers <- c(-4,7,23,-120309,0)


number_function <- function(numbers) {
  for (number in numbers) {
    if (number > 0) {
      print('this is positive number')
    }
    else if (number == 0) {
      print('the number is zero')
    }
    else {
      print('this is a negative number')
    }
  }
}

number_function(numbers)
```

Tip for C1: do it one by one first, and if you need more practice, do a for-loop and check them that way.

### C2 Write a script that categorizes a person's age: child (< 12), teenager (12-18), adult (19-65), senior (> 65) for the following ages
Ages: 
10
20
56
19
89
:) :) 26 <3 <3 

```{r}
some_ages <- c(10,20,56,19,89,26,-5)
age_function <-  function(ages){
  for (age in ages){
    if (age %in% 0:12){
      print('Child')
    }
    else if (age %in% 12:18){
      print('Teenager')
    }
    else if (age %in% 19:65){
      print('Adult')
    }
    else if (age > 65){
      print('Senior')
    }
    else {
      print('invalid age')
    }
  }
}

age_function(some_ages)
```

## D. Need some more practice in functions? 
### D1 Create a function that takes a vector of numbers and returns the mean of that vector.
(If you need to, check class 2's doc for how to write functions)
```{r}
#made a lot of functions above
```

### D2 Write a function named calculate_area_circle that takes the radius of a circle as its argument and returns the area of the circle. Remember, the formula to calculate the area of a circle is pi*r^2, where r is the radius of the circle.

```{r}
#made a lot of functions above
```

## E. Need some more practice in simulations? 
### E1 Write a simulation to mimic the rolling of two six-sided dice. Simulate rolling the two dice 10000 times and store the sum of the dice faces for each roll. Plot a histogram of the sums to see the distribution of the total dice rolls. Calculate and print the mean and standard deviation of the rolls.
```{r}
n_sims <- 10000
dice_rolls <- rep(NA,n_sims)


for (i in 1:n_sims){
  sum_rolls <- sum(sample(1:6,2, replace = TRUE))
  dice_rolls[i] <- sum_rolls
}
sim_data <- data.frame(dice_rolls)

ggplot(sim_data, aes(x = dice_rolls)) +
  geom_histogram(binwidth = 1)
print(paste('this is the mean',mean(sim_data$dice_rolls)))
print(paste('This is the sd',sd(sim_data$dice_rolls)))
```
### E2 Consider a population that grows exponentially according to the formula \(P = P_0e^{rt}\) (the e^{rt} part is written exp(r*t) in r), where \(P_0\) is the initial population size, \(r\) is the rate of growth, and \(t\) is time in years. Simulate the growth of a population starting with 100 individuals and a growth rate of 2% per year over 50 years. Plot the population size each year.

```{r}
pop_size <- c()
years <- c()
population_start <- 100
rate_of_growth <- 0.02
duration <- 50



pop_grow_function <- function(Pop, rate, time_){
  Population <- Pop*exp(rate*time_)
  return(Population)
}
for (i in 1:duration){
  pop_size[i] <- pop_grow_function(population_start,rate_of_growth,i)
  years[i] <- i
}
pop_df <- data.frame(pop_size,years)

ggplot(pop_df, aes(x = as.factor(years), y = pop_size)) +
  geom_bar(stat = "identity",fill = "skyblue", color = "black") +
  ggtitle("Population Size by Year") +
  xlab("Year") +
  ylab("Population Size")

```
### E3 Simulate the annual returns of an investment portfolio with an average return of 7% and a standard deviation of 10%. Assume the returns follow a normal distribution. Simulate 30 years of returns and calculate the final portfolio value assuming an initial investment of $10,000. Repeat this simulation 1000 times and plot a histogram of the final portfolio values. Calculate the mean and standard deviation of the final values.

```{r}
current_portfolio <- c()
year <- c()
mean_return <- 0.07
sd_return <- 0.1
investement_years <- 30
initial_investement <- 10000


for (i in 1:investement_years) {
  year[i] <- i
  yearly_return <- 1 + rnorm(1, mean_return, sd_return)
  
  if (i == 1) {
    portfolio <- initial_investement * yearly_return
    current_portfolio[i] <- portfolio
  } else {
    portfolio <- portfolio * yearly_return
    current_portfolio[i] <- portfolio
  }
  
}

portfolio_df <- data.frame(current_portfolio,year)

ggplot(portfolio_df, aes(x = as.factor(year), y = current_portfolio)) +
  geom_bar(stat = "identity",fill = "violet", color = "white") +
  ggtitle("Portfolio by year") +
  xlab("Year") +
  ylab("Portfolio size")
  
#Final portfolio value
portfolio_df$current_portfolio[investement_years]

```

make a 1000 simulations and find mean and sd for finalportfolio
```{r}
mean_return <- 0.07
sd_return <- 0.1
investement_years <- 30
initial_investement <- 10000
final_portfolio <- c()
n_sims <- 1000


for (i in 1:n_sims) {
  for (year_ in 1:investement_years) {
    yearly_return <- 1 + rnorm(1, mean_return, sd_return)
    if (year_ == 1) {
      portfolio <- initial_investement * yearly_return
    } else {
      portfolio <- portfolio * yearly_return
    }
  }
  final_portfolio[i] <- portfolio
} 

final_portfolio_df <- data.frame(final_portfolio)
#interestingly it seems normally distributed by log-transformation
final_portfolio_df <- 
  final_portfolio_df %>% mutate(final_portfolio_log = log(final_portfolio))

ggplot(final_portfolio_df, aes(x = final_portfolio)) +
  geom_histogram(binwidth = 10000, fill = 'skyblue', color = 'black') +
  ggtitle("Portfolio distribution") +
  xlab("Money after 30 years") +
  ylab("count") +
  theme_minimal()
  
print(paste('The mean portfolio value after 30 years is: ',
            round(mean(final_portfolio_df$final_portfolio)),
            'and the sd is: ', round(sd(final_portfolio_df$final_portfolio))))
```

#### E4 (Ex. 3.5 from the book) Probability distributions: Using a bar plot in R, graph the binomial distribution with n = 20 and p = 0.3.

```{r}
hits <- c()
for (i in 1:1000){
  hits[i] <- sum(rbinom(20,1,0.3))
}

hits <- data.frame(hits)
ggplot(hits, aes(x=hits))+
  geom_bar(fill = "pink", color = "black")+
  theme_minimal()
```

### E5 Sampling from a discrete distribution - rolling a loaded die
A loaded (or biased) die is one where the probabilities of landing on each number are not equal. Simulate rolling a loaded die 10,000 times, where the probabilities of rolling each number from 1 to 6 are given as follows: P(1) = 0.05, P(2) = 0.10, P(3) = 0.35, P(4) = 0.25, P(5) = 0.15, P(6) = 0.10. Plot a histogram of the outcomes and calculate the mean and standard deviation of the results.

```{r}
simulate_dice_roll <- function(probabilities) {
  if (sum(probabilities) != 1) {
    stop("Probabilities must sum to 1.")
  }
  
  # Simulate dice roll based on probabilities
  result <- sample(1:length(probabilities), size = 1, prob = probabilities)
  
  return(result)
}

coin_toss <- c()
custom_probabilities <- c(0.05, 0.10, 0.35, 0.25, 0.15, 0.10)

for (i in 1:10000){
  coin_toss[i] <- simulate_dice_roll(custom_probabilities)
}

coin_toss <- data.frame(coin_toss)

ggplot(coin_toss, aes(x = coin_toss))+
  geom_histogram(fill = 'darkgreen', 
                 color = 'black',
                 binwidth = 1)+
  theme_minimal()

mean(coin_toss$coin_toss)
sd(coin_toss$coin_toss)
```

### E6 Sampling from a continuous distribution - generating heights
Assume that the heights of individuals in a population are normally distributed with a mean of 170 cm and a standard deviation of 10 cm. Generate a sample of 1,000 individual heights from this distribution. Plot a histogram of the generated heights and calculate the mean and standard deviation of the sample.

```{r}
#easy
```

### E7 Simulating coin flips - Bernoulli Distribution
(this is something we work with on the master's hehe)
Simulate flipping a fair coin 5,000 times, where the outcome of each flip is either "Heads" or "Tails" with equal probability. Calculate and print the proportion of flips that result in Heads. This exercise demonstrates sampling from a Bernoulli distribution, which is a simple case of a discrete distribution.
```{r}
heads <- 0

for (i in 1:5000){
  coinflip <- rbinom(1,1,0.5)
  if (coinflip == 0){
    heads <- heads + 1
  }else{
  }
}

proportion_of_heads <- sum(heads)/5000
print(proportion_of_heads)
```

# A few more exercises from the book
## Chapter 3
#### Ex 3.3 Probability distributions: Using R, graph probability densities for the normal distribution, plotting several different curves corresponding to different choices of mean and standard deviation parameters.
A note: The task is to draw/plot some probability distributions for the normal distribution. From Methods 1 we learnt the normal distribution as just one thing that we want to compare our data against to e.g. check for normality of residuals. Actually, the normal distribution (also known as the gaussian) is also called family of distributions that can have any real value as the mean and any positive value as the standard deviation. The *standard* normal distribution is a special case of the normal distribution with a mean of 0 and standard deviation of 1, and this guy we know from Methods 1.

The point of this task is thus for you to see what happens when you vary the mean/standard deviation and nothing else in a distribution.
```{r}
# Define a range of x values
x <- seq(-5, 5, 0.1)

# Define different mean and standard deviation parameters
means <- c(0, 1, -2)
sds <- c(1, 0.5, 2)

# Plot normal distribution curves
for (i in 1:length(means)) {
  curve(dnorm(x, mean = means[i], sd = sds[i]), 
        col = i, lwd = 2, 
        main = "Normal Distribution Curves",
        xlab = "x", ylab = "Density",
        ylim = c(0, 1),
        xlim = c(-5,4),
        add = i > 1)
  legend("topright", legend = c(paste("Mean =", means[i], ", SD =", sds[i])), col = i, lwd = 2)
}

# Add a legend
legend("topright", legend = c("Mean = 0, SD = 1", "Mean = 1, SD = 0.5", "Mean = -2, SD = 2"), col = 1:3, lwd = 2)

```

#### Ex. 3.4 Probability distributions: Using a bar plot in R, graph the Poisson distribution with parameter 3.5.
(Remember when the book says 'graph' it means simulate some data as per instructions and make a plot)

```{r}
#will do some other time
```

# Hints for exercises A-E
## Hints for A
Hint A1: Start by making a variable called my_sum (or whatever you want to call it), starting at 0. Can you write code to loop through from i = 1 all the way to 100 and add each i to 'my_sum'? 

Hint A2: Create an empty vector (or a vector full of 0s or something) that's as long as you need it to be. Then in your for loop, use indexing in your vector to place your squared values. After the for loop has run, you can just do sum(your_vector_with_the_squared_values). 

## Hints for B
Hint B1: Start by defining a sum-tracker object, which will be used in the loop to check if it is below/equal to 1000 - because while (!) that is true, we want to add the next number to the sum-tracker. The while loop will stop when the condition youve set ISNT true anymore, and then, you should print the n it got to (so you also need to, before your while loop starts, define an n, which is the positive integer-holder).

Hint B2: For this loop, you're gonna be counting down, so subtracting something from an object you must define, and subtracting until 0. So your 'while' statement has to be like "while this object is OVER 0".
